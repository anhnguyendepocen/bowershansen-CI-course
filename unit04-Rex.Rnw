\documentclass{article}
%\usepackage{natbib}

\title{In pursuit of baseline comparability}
%\author{ICPSR Causal Inference '15}
\usepackage{icpsr-classwork}
\usepackage{natbib}

\begin{document}
\maketitle


We'll examine baseline comparability for two studies, Arceneaux et
al's (2005) Kansas City GOTV experiment and Cerda et al's (2012) study of
the Medellin Metrocable's effects on neighborhood violence.


<<results='hide'>>=
library(RItools)
library(optmatch)
acorn <- read.csv("data/acorn03.csv", row.names=1)
meddat <- read.csv('data/meddat.csv', 
                   colClasses=c("nhClass"="factor"))
@ 
(With the Medellin data we had to direct the software to interpret \texttt{nhClass}'s integer
codes as categories, not scalar measurements.  A 
codebook for the Medellin data set is available in
\texttt{data/meddat.R}, although as of this writing it's not entirely complete.)


\section{Balance checks for unstratified studies}

With the acorn data set, covariate balance checks out just fine.

<<>>=

xBalance(z ~ v_p2003 + v_m2003 + v_g2002 + v_p2002 + v_m2002 + v_s2001 + 
         v_g2000 + v_p2000 + v_m2000 + v_s1999 + v_m1999 + v_g1998 + 
         v_m1998 + v_s1998 + v_m1997 + v_s1997 + v_g1996 + v_p1996 + 
         v_m1996 + v_s1996 + size, data=acorn, 
         report = 'all')

@ 


For the Medellin comparison, it's not quite as clear.

<<>>=
xBalance(nhTrt ~ nhLogHom+nhClass+nhSisben+nhPopD+nhQP03+nhPV03+nhTP03+
                nhBI03+nhCE03+nhNB03+nhMale+nhAgeYoung+nhAgeMid+
                nhMarDom+nhSepDiv+nhOwn+nhRent+nhEmp+nhAboveHS+nhHS,
                data=meddat, report=c("std.diffs", "adj.means", "chisquare.test"))

@ 
\section{Addressing baseline imbalances via matching or subclassification}

\subsection{Subclassification}
There are many ways to subclassify.  A natural starting point is to
subclassify on the variable that appeared to be most out of balance
in the initial baseline comparability check.

<<eval=FALSE>>=
xBalance(nhTrt ~ nhLogHom+
         strata(nhClass)+
         nhSisben+nhPopD+nhQP03+nhPV03+nhTP03+
                nhBI03+nhCE03+nhNB03+nhMale+nhAgeYoung+nhAgeMid+
                nhMarDom+nhSepDiv+nhOwn+nhRent+nhEmp+nhAboveHS+nhHS,
                data=meddat, report=c("std.diffs", "adj.means", "chisquare.test"))

@ 
 
<<echo=FALSE>>=
xBalance(nhTrt ~ nhLogHom+
         nhSisben+nhPopD+nhQP03+nhPV03+nhTP03+
                nhBI03+nhCE03+nhNB03+nhMale+nhAgeYoung+nhAgeMid+
                nhMarDom+nhSepDiv+nhOwn+nhRent+nhEmp+nhAboveHS+nhHS,
                strata=list(nhClass=~nhClass),
                data=meddat, report=c("std.diffs", "adj.means", "chisquare.test"))
@ 
Quite a bit better! 

\paragraph{Remarks.}  
\begin{enumerate}
\item 
The use of \texttt{strata()} to specifying a stratifying variable was introduced in
RItools version 0.1-13.  If you have an earlier version, update or
check out the help page for the old way.
\item Strictly speaking, this is
\textit{poststratification}, not stratification, since these strata
were specified after the fact and played no explicit role in the
process of assigning treatment.
\item This particular post-stratification, but has the side effect of
  removing quite a few observations from the comparison, and in
  general cutting into the effective sample size of the comparison:
\end{enumerate}

<<>>=
with(meddat, table(nhTrt, nhClass) )
@ 

We should ask ourselves whether exact matching on neighborhood class
really is a necessity, or whether we could make do with some
across-neighborhood comparisons.  For Cerda et al, the answer was
that it was o.k. to match across neighborhood category, particularly
if the \textit{nhClass} variable could be balanced about as well as
we'd expect it to be in a natural experiment. 

\subsection{Matching}

There are many ways to match.  As a starting point, it's natural to
form nonoverlapping pairs on the basis of a measurement variable
that differs between treatment and control and that unambiguously
matters to outcomes of interest. 

<<>>=
pairs.m <- pairmatch(nhTrt~nhLogHom, data=meddat)
xBalance(nhTrt ~ nhLogHom+nhClass+nhSisben+nhPopD+nhQP03+nhPV03+nhTP03+
                nhBI03+nhCE03+nhNB03+nhMale+nhAgeYoung+nhAgeMid+
                nhMarDom+nhSepDiv+nhOwn+nhRent+nhEmp+nhAboveHS+nhHS,
                strata=list(pairs=~pairs.m), data=meddat, 
         report=c("std.diffs", "adj.means", "chisquare.test"))
@ 

Given the sizes of treatment and control groups, our decision to
match in nonoverlapping pairs meant that a few control neighborhoods
would have to be left out:
<<>>=
with(meddat, table(nhTrt, nhClass) )
@ 
This omission is the whole and entire
source of the improvements in balance that we saw above!

<<>>=
xBalance(nhTrt ~ nhLogHom+nhClass+nhSisben+nhPopD+nhQP03+nhPV03+nhTP03+
                nhBI03+nhCE03+nhNB03+nhMale+nhAgeYoung+nhAgeMid+
                nhMarDom+nhSepDiv+nhOwn+nhRent+nhEmp+nhAboveHS+nhHS,
                strata=list(unstrat=NULL, pairs=~pairs.m), data=meddat,
         report=c("adj.means", "std.diffs", "chisquare.test"))
@ 

The \textit{optmatch} package provides a function to translate these
structural differences into effective sample sizes, presented in
matched pair equivalents.  
<<>>=

with(meddat, stratumStructure(nhClass, nhTrt))
with(meddat, stratumStructure(pairs.m, nhTrt)) 


@ 
Given that it's using an \texttt{optmatch}-generated matching
structure, the latter is equivalent to
<<>>=
with(meddat, stratumStructure(pairs.m))
@ 
The simplifying assumptions underlying these
calculation are that under either
stratification you'd compare means
by stratum, and that each stratum, under either stratification, has
the same outcome variance. 
\section*{Notes and references}


R and R package versions used in this demo:
<<>>=
sessionInfo()
@ 
\end{document}
